# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

#----------------------------------------------------------------------------
# The datatype of components in the attribute.
# gltf_detailedDescription: The datatype of components in the attribute.  All valid values correspond to WebGL enums.  The corresponding typed arrays are `Int8Array`, `Uint8Array`, `Int16Array`, `Uint16Array`, `Uint32Array`, and `Float32Array`, respectively.  5125 (UNSIGNED_INT) is only allowed when the accessor contains indices, i.e., the accessor is only referenced by `primitive.indices`.
# gltf_webgl: `vertexAttribPointer()` type parameter
class ComponentType(object):
    BYTE = 5120
    UNSIGNED_BYTE = 5121
    SHORT = 5122
    UNSIGNED_SHORT = 5123
    UNSIGNED_INT = 5125
    FLOAT = 5126


# "description": "Specifies if the attribute is a scalar, vector, or matrix."
class AccessorType(object):
    SCALAR = 0
    VEC2 = 1
    VEC3 = 2
    VEC4 = 3
    MAT2 = 4
    MAT3 = 5
    MAT4 = 6


#----------------------------------------------------------------------------
# "description": "The name of the node's TRS property to modify, or the \"weights\" of the Morph Targets it instantiates."
class AnimationChannelTargetPath(object):
    translation = 0
    rotation = 1
    scale = 2
    weights = 3


# "description": "Interpolation algorithm."
# "gltf_detailedDescription": "Interpolation algorithm."
class AnimationSamplerInterpolationAlgorithm(object):
    # "description": "The animated values are linearly interpolated between keyframes. When targeting a rotation, spherical linear interpolation (slerp) should be used to interpolate quaternions. The number output of elements must equal the number of input elements."
    LINEAR = 0
    # "description": "The animated values remain constant to the output of the first keyframe, until the next keyframe. The number of output elements must equal the number of input elements."
    STEP = 1
    # "description": "The animation's interpolation is computed using a uniform Catmull-Rom spline. The number of output elements must equal two more than the number of input elements. The first and last output elements represent the start and end tangents of the spline. There must be at least four keyframes when using this interpolation."
    CATMULLROMSPLINE = 2
    # "description": "The animation's interpolation is computed using a cubic spline with specified tangents. The number of output elements must equal three times the number of input elements. For each input element, the output stores three elements, an in-tangent, a spline vertex, and an out-tangent. There must be at least two keyframes when using this interpolation."
    CUBICSPLINE = 3


#----------------------------------------------------------------------------
# "description": "The target that the GPU buffer should be bound to."
# "gltf_webgl": "`bindBuffer()`"
class BufferViewTarget(object):
    ARRAY_BUFFER = 34962
    ELEMENT_ARRAY_BUFFER = 34963
    # originally added for flatgltf
    UNIFORM_BUFFER = 35345


# "description": "Specifies if the camera uses a perspective or orthographic projection."
# "gltf_detailedDescription": "Specifies if the camera uses a perspective or orthographic projection.  Based on this, either the camera's `perspective` or `orthographic` property will be defined."
class CameraType(object):
    perspective = 0
    orthographic = 1


# "description": "The alpha rendering mode of the material."
# "gltf_detailedDescription": "The material's alpha rendering mode enumeration specifying the interpretation of the alpha value of the main factor and texture."
class MaterialAlphaMode(object):
    # "description": "The alpha value is ignored and the rendered output is fully opaque."
    OPAQUE = 0
    # "description": "The rendered output is either fully opaque or fully transparent depending on the alpha value and the specified alpha cutoff value."
    MASK = 1
    # "description": "The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator)."
    BLEND = 2


#----------------------------------------------------------------------------
class MeshPrimitiveMode(object):
    POINTS = 0
    LINES = 1
    LINE_LOOP = 2
    LINE_STRIP = 3
    TRIANGLES = 4
    TRIANGLE_STRIP = 5
    TRIANGLE_FAN = 6


#----------------------------------------------------------------------------
# "gltf_detailedDescription": "All valid values correspond to WebGL enums."
class SamplerFilter(object):
    NEAREST = 9728
    LINEAR = 9729
    NEAREST_MIPMAP_NEAREST = 9984
    LINEAR_MIPMAP_NEAREST = 9985
    NEAREST_MIPMAP_LINEAR = 9986
    LINEAR_MIPMAP_LINEAR = 9987


# "gltf_detailedDescription": "All valid values correspond to WebGL enums."
class WrapMode(object):
    REPEAT = 10497
    CLAMP_TO_EDGE = 33071
    MIRRORED_REPEAT = 33648


class AccessorSparseIndices(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = AccessorSparseIndices()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAccessorSparseIndices(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # AccessorSparseIndices
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "The index of the bufferView with sparse indices. Referenced bufferView can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target."
    # AccessorSparseIndices
    def BufferView(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

    # "description": "The offset relative to the start of the bufferView in bytes. Must be aligned."
    # AccessorSparseIndices
    def ByteOffset(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # AccessorSparseIndices
    def ComponentType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 5121

    # Dictionary object with extension-specific objects.
    # AccessorSparseIndices
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # AccessorSparseIndices
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # AccessorSparseIndices
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AccessorSparseIndices
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # Application-specific data.
    # AccessorSparseIndices
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # AccessorSparseIndices
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # AccessorSparseIndices
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AccessorSparseIndices
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def AccessorSparseIndicesStart(builder):
    builder.StartObject(5)

def AccessorSparseIndicesAddBufferView(builder, bufferView):
    builder.PrependInt32Slot(0, bufferView, -1)

def AccessorSparseIndicesAddByteOffset(builder, byteOffset):
    builder.PrependUint32Slot(1, byteOffset, 0)

def AccessorSparseIndicesAddComponentType(builder, componentType):
    builder.PrependUint32Slot(2, componentType, 5121)

def AccessorSparseIndicesAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def AccessorSparseIndicesStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AccessorSparseIndicesAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def AccessorSparseIndicesStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AccessorSparseIndicesEnd(builder):
    return builder.EndObject()



class AccessorSparseValues(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = AccessorSparseValues()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAccessorSparseValues(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # AccessorSparseValues
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "The index of the bufferView with sparse values. Referenced bufferView can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target."
    # AccessorSparseValues
    def BufferView(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

    # "description": "The offset relative to the start of the bufferView in bytes. Must be aligned."
    # AccessorSparseValues
    def ByteOffset(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Dictionary object with extension-specific objects.
    # AccessorSparseValues
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # AccessorSparseValues
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # AccessorSparseValues
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AccessorSparseValues
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Application-specific data.
    # AccessorSparseValues
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # AccessorSparseValues
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # AccessorSparseValues
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AccessorSparseValues
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

def AccessorSparseValuesStart(builder):
    builder.StartObject(4)

def AccessorSparseValuesAddBufferView(builder, bufferView):
    builder.PrependInt32Slot(0, bufferView, -1)

def AccessorSparseValuesAddByteOffset(builder, byteOffset):
    builder.PrependInt32Slot(1, byteOffset, 0)

def AccessorSparseValuesAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def AccessorSparseValuesStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AccessorSparseValuesAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def AccessorSparseValuesStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AccessorSparseValuesEnd(builder):
    return builder.EndObject()



# Accessor Sparse
class AccessorSparse(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = AccessorSparse()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAccessorSparse(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # AccessorSparse
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "Number of entries stored in the sparse array."
    # "gltf_detailedDescription": "The number of attributes encoded in this sparse accessor."
    # "minimum": 1
    # AccessorSparse
    def Count(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # "description": "Index array of size `count` that points to those accessor attributes that deviate from their initialization value. Indices must strictly increase."
    # AccessorSparse
    def Indices(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = AccessorSparseIndices()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # "description": "Array of size `count` times number of components, storing the displaced accessor attributes pointed by `indices`. Substituted values must have the same `componentType` and number of components as the base accessor."
    # AccessorSparse
    def Values(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = AccessorSparseValues()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Dictionary object with extension-specific objects.
    # AccessorSparse
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # AccessorSparse
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # AccessorSparse
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AccessorSparse
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # Application-specific data.
    # AccessorSparse
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # AccessorSparse
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # AccessorSparse
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AccessorSparse
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def AccessorSparseStart(builder):
    builder.StartObject(5)

def AccessorSparseAddCount(builder, count):
    builder.PrependInt32Slot(0, count, 0)

def AccessorSparseAddIndices(builder, indices):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(indices), 0)

def AccessorSparseAddValues(builder, values):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(values), 0)

def AccessorSparseAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def AccessorSparseStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AccessorSparseAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def AccessorSparseStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AccessorSparseEnd(builder):
    return builder.EndObject()



# A typed view into a bufferView.  A bufferView contains raw binary data.  An accessor provides a typed view into a bufferView or a subset of a bufferView similar to how WebGL's `vertexAttribPointer()` defines an attribute in a buffer.
class Accessor(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Accessor()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAccessor(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Accessor
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "The index of the bufferView."
    # "gltf_detailedDescription": "The index of the bufferView. When not defined, accessor must be initialized with zeros; `sparse` property or extensions could override zeros with actual values."    
    # Accessor
    def BufferView(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

    # "description": "The offset relative to the start of the bufferView in bytes."
    # "gltf_detailedDescription": "The offset relative to the start of the bufferView in bytes.  This must be a multiple of the size of the component datatype."
    # "gltf_webgl": "`vertexAttribPointer()` offset parameter"
    # Accessor
    def ByteOffset(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # "description": "The datatype of components in the attribute."
    # "gltf_detailedDescription": "The datatype of components in the attribute.  All valid values correspond to WebGL enums.  The corresponding typed arrays are `Int8Array`, `Uint8Array`, `Int16Array`, `Uint16Array`, `Uint32Array`, and `Float32Array`, respectively.  5125 (UNSIGNED_INT) is only allowed when the accessor contains indices, i.e., the accessor is only referenced by `primitive.indices`."
    # "gltf_webgl": "`vertexAttribPointer()` type parameter"
    # Accessor
    def ComponentType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 5120

    # "description": "The number of attributes referenced by this accessor."
    # "gltf_detailedDescription": "The number of attributes referenced by this accessor, not to be confused with the number of bytes or number of components."
    # Accessor
    def Count(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # "description": "Sparse storage of attributes that deviate from their initialization value."
    # Accessor
    def Sparse(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = AccessorSparse()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # The user-defined name of this object.
    # gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an accessor and a buffer could have the same name, or two accessors could even have the same name.
    # Accessor
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    #  "description": "Maximum value of each component in this attribute."
    # "minItems": 1,
    # "maxItems": 16,
    # "gltf_detailedDescription": "Maximum value of each component in this attribute.  Array elements must be treated as having the same data type as accessor's `componentType`. Both min and max arrays have the same length.  The length is determined by the value of the type property; it can be 1, 2, 3, 4, 9, or 16.\n\n`normalized` property has no effect on array values: they always correspond to the actual values stored in the buffer. When accessor is sparse, this property must contain max values of accessor data with sparse substitution applied."
    # Accessor
    def Max(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Accessor
    def MaxAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # Accessor
    def MaxLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Accessor
    def MaxIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # "description": "Minimum value of each component in this attribute."
    # "minItems": 1,
    # "maxItems": 16,
    # "gltf_detailedDescription": "Minimum value of each component in this attribute.  Array elements must be treated as having the same data type as accessor's `componentType`. Both min and max arrays have the same length.  The length is determined by the value of the type property; it can be 1, 2, 3, 4, 9, or 16.\n\n`normalized` property has no effect on array values: they always correspond to the actual values stored in the buffer. When accessor is sparse, this property must contain min values of accessor data with sparse substitution applied."
    # Accessor
    def Min(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Accessor
    def MinAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # Accessor
    def MinLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Accessor
    def MinIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # Dictionary object with extension-specific objects.
    # Accessor
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Accessor
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Accessor
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Accessor
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return o == 0

    # "description": "Specifies whether integer data values should be normalized."
    # "gltf_detailedDescription": "Specifies whether integer data values should be normalized (`true`) to [0, 1] (for unsigned types) or [-1, 1] (for signed types), or converted directly (`false`) when they are accessed. This property is defined only for accessors that contain vertex attributes or animation output data."
    # "gltf_webgl": "`vertexAttribPointer()` normalized parameter"
    # Accessor
    def Normalized(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Application-specific data.
    # Accessor
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Accessor
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Accessor
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Accessor
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        return o == 0

    # "description": "Specifies if the attribute is a scalar, vector, or matrix."
    # Accessor
    def Type(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

def AccessorStart(builder):
    builder.StartObject(12)

def AccessorAddBufferView(builder, bufferView):
    builder.PrependInt32Slot(0, bufferView, -1)

def AccessorAddByteOffset(builder, byteOffset):
    builder.PrependInt32Slot(1, byteOffset, 0)

def AccessorAddComponentType(builder, componentType):
    builder.PrependUint32Slot(2, componentType, 5120)

def AccessorAddCount(builder, count):
    builder.PrependInt32Slot(3, count, 0)

def AccessorAddSparse(builder, sparse):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(sparse), 0)

def AccessorAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def AccessorAddMax(builder, max):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(max), 0)

def AccessorStartMaxVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def AccessorAddMin(builder, min):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(min), 0)

def AccessorStartMinVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def AccessorAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def AccessorStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AccessorAddNormalized(builder, normalized):
    builder.PrependBoolSlot(9, normalized, 0)

def AccessorAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def AccessorStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AccessorAddType(builder, type):
    builder.PrependInt8Slot(11, type, 0)

def AccessorEnd(builder):
    return builder.EndObject()



#----------------------------------------------------------------------------
# Asset
# Metadata about the glTF asset.
class Asset(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Asset()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAsset(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Asset
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # The user-defined name of this object.
    # gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an accessor and a buffer could have the same name, or two accessors could even have the same name.
    # Asset
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Dictionary object with extension-specific objects.
    # Asset
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Asset
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Asset
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Asset
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Application-specific data.
    # Asset
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Asset
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Asset
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Asset
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Tool that generated this glTF model.  Useful for debugging.
    # Asset
    def Generator(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The minimum glTF version that this asset targets.
    # pattern": "^[0-9]+\\.[0-9]+$
    # Asset
    def MinVersion(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The glTF version that this asset targets.
    # pattern: "^[0-9]+\\.[0-9]+$"
    # Asset
    def Version(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # A copyright message suitable for display to credit the content creator.
    # Asset
    def Copyright(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def AssetStart(builder):
    builder.StartObject(7)

def AssetAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def AssetAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def AssetStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AssetAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def AssetStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AssetAddGenerator(builder, generator):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(generator), 0)

def AssetAddMinVersion(builder, minVersion):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(minVersion), 0)

def AssetAddVersion(builder, version):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(version), 0)

def AssetAddCopyright(builder, copyright):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(copyright), 0)

def AssetEnd(builder):
    return builder.EndObject()



# Animation Channel Target
# "description": "The index of the node and TRS property that an animation channel targets."
class AnimationChannelTarget(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = AnimationChannelTarget()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAnimationChannelTarget(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # AnimationChannelTarget
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Dictionary object with extension-specific objects.
    # AnimationChannelTarget
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # AnimationChannelTarget
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # AnimationChannelTarget
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AnimationChannelTarget
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Application-specific data.
    # AnimationChannelTarget
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # AnimationChannelTarget
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # AnimationChannelTarget
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AnimationChannelTarget
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # "description": "The index of the node to target."
    # AnimationChannelTarget
    def Node(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

    # "description": "The name of the node's TRS property to modify, or the \"weights\" of the Morph Targets it instantiates."
    # AnimationChannelTarget
    def Path(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

def AnimationChannelTargetStart(builder):
    builder.StartObject(4)

def AnimationChannelTargetAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def AnimationChannelTargetStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AnimationChannelTargetAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def AnimationChannelTargetStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AnimationChannelTargetAddNode(builder, node):
    builder.PrependInt32Slot(2, node, -1)

def AnimationChannelTargetAddPath(builder, path):
    builder.PrependInt8Slot(3, path, 0)

def AnimationChannelTargetEnd(builder):
    return builder.EndObject()



# Animation Channel
# "description": "Targets an animation's sampler at a node's property."
class AnimationChannel(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = AnimationChannel()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAnimationChannel(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # AnimationChannel
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Dictionary object with extension-specific objects.
    # AnimationChannel
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # AnimationChannel
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # AnimationChannel
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AnimationChannel
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Application-specific data.
    # AnimationChannel
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # AnimationChannel
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # AnimationChannel
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AnimationChannel
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # "description": "The index of a sampler in this animation used to compute the value for the target."
    # "gltf_detailedDescription": "The index of a sampler in this animation used to compute the value for the target, e.g., a node's translation, rotation, or scale (TRS)."
    # AnimationChannel
    def Sampler(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # "description": "The index of the node and TRS property to target."
    # AnimationChannel
    def Target(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = AnimationChannelTarget()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def AnimationChannelStart(builder):
    builder.StartObject(4)

def AnimationChannelAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def AnimationChannelStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AnimationChannelAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def AnimationChannelStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AnimationChannelAddSampler(builder, sampler):
    builder.PrependInt32Slot(2, sampler, 0)

def AnimationChannelAddTarget(builder, target):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(target), 0)

def AnimationChannelEnd(builder):
    return builder.EndObject()



# Animation Sampler
# "description": "Combines input and output accessors with an interpolation algorithm to define a keyframe graph (but not its target)."
class AnimationSampler(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = AnimationSampler()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAnimationSampler(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # AnimationSampler
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Application-specific data.
    # AnimationSampler
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # AnimationSampler
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # AnimationSampler
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AnimationSampler
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Dictionary object with extension-specific objects.
    # AnimationSampler
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # AnimationSampler
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # AnimationSampler
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AnimationSampler
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # "description": "The index of an accessor containing keyframe input values, e.g., time."
    # "gltf_detailedDescription": "The index of an accessor containing keyframe input values, e.g., time. That accessor must have componentType `FLOAT`. The values represent time in seconds with `time[0] >= 0.0`, and strictly increasing values, i.e., `time[n + 1] > time[n]`."
    # AnimationSampler
    def Input(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # "description": "Interpolation algorithm."
    # "gltf_detailedDescription": "Interpolation algorithm."
    # AnimationSampler
    def Interpolation(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # "description": "The index of an accessor, containing keyframe output values."
    # "gltf_detailedDescription": "The index of an accessor containing keyframe output values. When targeting TRS target, the `accessor.componentType` of the output values must be `FLOAT`. When targeting morph weights, the `accessor.componentType` of the output values must be `FLOAT` or normalized integer where each output element stores values with a count equal to the number of morph targets."
    # AnimationSampler
    def Output(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def AnimationSamplerStart(builder):
    builder.StartObject(5)

def AnimationSamplerAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def AnimationSamplerStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AnimationSamplerAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def AnimationSamplerStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AnimationSamplerAddInput(builder, input):
    builder.PrependInt32Slot(2, input, 0)

def AnimationSamplerAddInterpolation(builder, interpolation):
    builder.PrependInt8Slot(3, interpolation, 0)

def AnimationSamplerAddOutput(builder, output):
    builder.PrependInt32Slot(4, output, 0)

def AnimationSamplerEnd(builder):
    return builder.EndObject()



# Animation
# "description": "A keyframe animation."
class Animation(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Animation()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAnimation(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Animation
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "An array of channels, each of which targets an animation's sampler at a node's property. Different channels of the same animation can't have equal targets."
    # Animation
    def Channels(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = AnimationChannel()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Animation
    def ChannelsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Animation
    def ChannelsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Dictionary object with extension-specific objects.
    # Animation
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Animation
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Animation
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Animation
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Application-specific data.
    # Animation
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Animation
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Animation
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Animation
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # The user-defined name of this object.
    # gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an accessor and a buffer could have the same name, or two accessors could even have the same name.
    # Animation
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # "description": "An array of samplers that combines input and output accessors with an interpolation algorithm to define a keyframe graph (but not its target)."
    # Animation
    def Samplers(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = AnimationSampler()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Animation
    def SamplersLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Animation
    def SamplersIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def AnimationStart(builder):
    builder.StartObject(5)

def AnimationAddChannels(builder, channels):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(channels), 0)

def AnimationStartChannelsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def AnimationAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def AnimationStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AnimationAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def AnimationStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def AnimationAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def AnimationAddSamplers(builder, samplers):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(samplers), 0)

def AnimationStartSamplersVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def AnimationEnd(builder):
    return builder.EndObject()



#----------------------------------------------------------------------------
# Buffer
# "description": "A buffer points to binary geometry, animation, or skins."
class Buffer(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Buffer()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBuffer(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Buffer
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "The length of the buffer in bytes."
    # Buffer
    def ByteLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # "description": "The uri of the buffer."
    # "format": "uriref"
    # "gltf_detailedDescription": "The uri of the buffer.  Relative paths are relative to the .gltf file.  Instead of referencing an external file, the uri can also be a data-uri."
    # "gltf_uriType": "application"
    # Buffer
    def Uri(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The user-defined name of this object.
    # gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an accessor and a buffer could have the same name, or two accessors could even have the same name.
    # Buffer
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Dictionary object with extension-specific objects.
    # Buffer
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Buffer
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Buffer
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Buffer
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # Application-specific data.
    # Buffer
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Buffer
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Buffer
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Buffer
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def BufferStart(builder):
    builder.StartObject(5)

def BufferAddByteLength(builder, byteLength):
    builder.PrependUint32Slot(0, byteLength, 0)

def BufferAddUri(builder, uri):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(uri), 0)

def BufferAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def BufferAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def BufferStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def BufferAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def BufferStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def BufferEnd(builder):
    return builder.EndObject()



# Buffer View
# "description": "A view into a buffer generally representing a subset of the buffer."
class BufferView(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = BufferView()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBufferView(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # BufferView
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "The index of the buffer."
    # BufferView
    def Buffer(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # BufferView
    def ByteLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # "description": "The offset into the buffer in bytes."
    # BufferView
    def ByteOffset(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # "description": "The stride, in bytes."
    # "minimum": 4
    # "maximum": 252
    # "multipleOf": 4
    # "gltf_detailedDescription": "The stride, in bytes, between vertex attributes.  When this is not defined, data is tightly packed. When two or more accessors use the same bufferView, this field must be defined."
    # "gltf_webgl": "`vertexAttribPointer()` stride parameter"
    # BufferView
    def ByteStride(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # "description": "The target that the GPU buffer should be bound to."
    # "gltf_webgl": "`bindBuffer()`"     
    # BufferView
    def Target(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 34962

    # The user-defined name of this object.
    # gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an accessor and a buffer could have the same name, or two accessors could even have the same name.
    # BufferView
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Dictionary object with extension-specific objects.
    # BufferView
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # BufferView
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # BufferView
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # BufferView
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # Application-specific data.
    # BufferView
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # BufferView
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # BufferView
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # BufferView
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

def BufferViewStart(builder):
    builder.StartObject(8)

def BufferViewAddBuffer(builder, buffer):
    builder.PrependUint32Slot(0, buffer, 0)

def BufferViewAddByteLength(builder, byteLength):
    builder.PrependUint32Slot(1, byteLength, 0)

def BufferViewAddByteOffset(builder, byteOffset):
    builder.PrependUint32Slot(2, byteOffset, 0)

def BufferViewAddByteStride(builder, byteStride):
    builder.PrependUint32Slot(3, byteStride, 0)

def BufferViewAddTarget(builder, target):
    builder.PrependInt32Slot(4, target, 34962)

def BufferViewAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def BufferViewAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def BufferViewStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def BufferViewAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def BufferViewStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def BufferViewEnd(builder):
    return builder.EndObject()



#----------------------------------------------------------------------------
# Camera Orthographic
# "description": "An orthographic camera containing properties to create an orthographic projection matrix."
class CameraOrthographic(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = CameraOrthographic()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsCameraOrthographic(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # CameraOrthographic
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "The floating-point horizontal magnification of the view. Must not be zero."
    # CameraOrthographic
    def Xmag(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # "description": "The floating-point vertical magnification of the view. Must not be zero."
    # CameraOrthographic
    def Ymag(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # "description": "The floating-point distance to the far clipping plane. `zfar` must be greater than `znear`."
    # CameraOrthographic
    def Zfar(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # "description": "The floating-point distance to the near clipping plane."
    # CameraOrthographic
    def Znear(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # Dictionary object with extension-specific objects.
    # CameraOrthographic
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # CameraOrthographic
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # CameraOrthographic
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # CameraOrthographic
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # Application-specific data.
    # CameraOrthographic
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # CameraOrthographic
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # CameraOrthographic
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # CameraOrthographic
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

def CameraOrthographicStart(builder):
    builder.StartObject(6)

def CameraOrthographicAddXmag(builder, xmag):
    builder.PrependFloat32Slot(0, xmag, 0.0)

def CameraOrthographicAddYmag(builder, ymag):
    builder.PrependFloat32Slot(1, ymag, 0.0)

def CameraOrthographicAddZfar(builder, zfar):
    builder.PrependFloat32Slot(2, zfar, 0.0)

def CameraOrthographicAddZnear(builder, znear):
    builder.PrependFloat32Slot(3, znear, 0.0)

def CameraOrthographicAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def CameraOrthographicStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def CameraOrthographicAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def CameraOrthographicStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def CameraOrthographicEnd(builder):
    return builder.EndObject()



# Camera Perspective
# "description": "A perspective camera containing properties to create a perspective projection matrix."
class CameraPerspective(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = CameraPerspective()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsCameraPerspective(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # CameraPerspective
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "The floating-point aspect ratio of the field of view."
    # "gltf_detailedDescription": "The floating-point aspect ratio of the field of view. When this is undefined, the aspect ratio of the canvas is used."
    # CameraPerspective
    def AspectRatio(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # Dictionary object with extension-specific objects.
    # CameraPerspective
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # CameraPerspective
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # CameraPerspective
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # CameraPerspective
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Application-specific data.
    # CameraPerspective
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # CameraPerspective
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # CameraPerspective
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # CameraPerspective
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # "description": "The floating-point vertical field of view in radians."
    # CameraPerspective
    def Yfov(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # "description": "The floating-point distance to the far clipping plane."
    # "gltf_detailedDescription": "The floating-point distance to the far clipping plane. When defined, `zfar` must be greater than `znear`. If `zfar` is undefined, runtime must use infinite projection matrix."
    # CameraPerspective
    def Zfar(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # "description": "The floating-point distance to the near clipping plane."
    # "gltf_detailedDescription": "The floating-point distance to the near clipping plane."
    # CameraPerspective
    def Znear(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

def CameraPerspectiveStart(builder):
    builder.StartObject(6)

def CameraPerspectiveAddAspectRatio(builder, aspectRatio):
    builder.PrependFloat32Slot(0, aspectRatio, 0.0)

def CameraPerspectiveAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def CameraPerspectiveStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def CameraPerspectiveAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def CameraPerspectiveStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def CameraPerspectiveAddYfov(builder, yfov):
    builder.PrependFloat32Slot(3, yfov, 0.0)

def CameraPerspectiveAddZfar(builder, zfar):
    builder.PrependFloat32Slot(4, zfar, 0.0)

def CameraPerspectiveAddZnear(builder, znear):
    builder.PrependFloat32Slot(5, znear, 0.0)

def CameraPerspectiveEnd(builder):
    return builder.EndObject()



class Camera(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Camera()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsCamera(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Camera
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Dictionary object with extension-specific objects.
    # Camera
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Camera
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Camera
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Camera
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Application-specific data.
    # Camera
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Camera
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Camera
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Camera
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # "description": "Specifies if the camera uses a perspective or orthographic projection."
    # "gltf_detailedDescription": "Specifies if the camera uses a perspective or orthographic projection.  Based on this, either the camera's `perspective` or `orthographic` property will be defined."
    # Camera
    def Type(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)
        return 0

    # The user-defined name of this object.
    # gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an accessor and a buffer could have the same name, or two accessors could even have the same name.
    # Camera
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # "description": "A perspective camera containing properties to create a perspective projection matrix."
    # Camera
    def Perspective(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = CameraPerspective()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # "description": "An orthographic camera containing properties to create an orthographic projection matrix."
    # Camera
    def Orthographic(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = CameraOrthographic()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def CameraStart(builder):
    builder.StartObject(6)

def CameraAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def CameraStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def CameraAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def CameraStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def CameraAddType(builder, type):
    builder.PrependInt16Slot(2, type, 0)

def CameraAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def CameraAddPerspective(builder, perspective):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(perspective), 0)

def CameraAddOrthographic(builder, orthographic):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(orthographic), 0)

def CameraEnd(builder):
    return builder.EndObject()



#----------------------------------------------------------------------------
# Image
# "description": "Image data used to create a texture. Image can be referenced by URI or `bufferView` index. `mimeType` is required in the latter case."
class Image(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Image()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsImage(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Image
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Dictionary object with extension-specific objects.
    # Image
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Image
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Image
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Image
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Application-specific data.
    # Image
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Image
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Image
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Image
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # "description": "The index of the bufferView that contains the image. Use this instead of the image's uri property."
    # Image
    def BufferView(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

    # "description": "The image's MIME type."
    # NOTE: JsonSchema states enum { "image/jpeg" "image/png" }, but this type of variables are not possible with flatbuffers, hence keeping the mimeType as string
    # Image
    def MimeType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The user-defined name of this object.
    # gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an accessor and a buffer could have the same name, or two accessors could even have the same name.
    # Image
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # "description": "The uri of the image."
    # "gltf_detailedDescription": "The uri of the image.  Relative paths are relative to the .gltf file.  Instead of referencing an external file, the uri can also be a data-uri.  The image format must be jpg or png."
    # "gltf_uriType": "image"
    # "format": "uriref"
    # Image
    def Uri(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def ImageStart(builder):
    builder.StartObject(6)

def ImageAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def ImageStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def ImageAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def ImageStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def ImageAddBufferView(builder, bufferView):
    builder.PrependInt32Slot(2, bufferView, -1)

def ImageAddMimeType(builder, mimeType):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(mimeType), 0)

def ImageAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def ImageAddUri(builder, uri):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(uri), 0)

def ImageEnd(builder):
    return builder.EndObject()



#----------------------------------------------------------------------------
# Texture Info
# "description": "Reference to a texture."
class TextureInfo(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TextureInfo()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTextureInfo(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # TextureInfo
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "The index of the texture."
    # TextureInfo
    def Index(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

    # "description": "The set index of texture's TEXCOORD attribute used for texture coordinate mapping."
    # "gltf_detailedDescription": "This integer value is used to construct a string in the format TEXCOORD_<set index> which is a reference to a key in mesh.primitives.attributes (e.g. A value of 0 corresponds to TEXCOORD_0)."
    # TextureInfo
    def TexCoord(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Dictionary object with extension-specific objects.
    # TextureInfo
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # TextureInfo
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # TextureInfo
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TextureInfo
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Application-specific data.
    # TextureInfo
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # TextureInfo
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # TextureInfo
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TextureInfo
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

def TextureInfoStart(builder):
    builder.StartObject(4)

def TextureInfoAddIndex(builder, index):
    builder.PrependInt32Slot(0, index, -1)

def TextureInfoAddTexCoord(builder, texCoord):
    builder.PrependInt32Slot(1, texCoord, 0)

def TextureInfoAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def TextureInfoStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def TextureInfoAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def TextureInfoStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def TextureInfoEnd(builder):
    return builder.EndObject()



#----------------------------------------------------------------------------
# Material Normal Texture Info
class MaterialNormalTextureInfo(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = MaterialNormalTextureInfo()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMaterialNormalTextureInfo(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # MaterialNormalTextureInfo
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "The scalar multiplier applied to each normal vector of the normal texture."
    # "gltf_detailedDescription": "The scalar multiplier applied to each normal vector of the texture. This value scales the normal vector using the formula: `scaledNormal =  normalize((normalize(<sampled normal texture value>) * 2.0 - 1.0) * vec3(<normal scale>, <normal scale>, 1.0))`. This value is ignored if normalTexture is not specified. This value is linear."
    # MaterialNormalTextureInfo
    def Scale(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 1.0

    #-- TextureInfo
    # "description": "The index of the texture."
    # MaterialNormalTextureInfo
    def Index(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

    # "description": "The set index of texture's TEXCOORD attribute used for texture coordinate mapping."
    # "gltf_detailedDescription": "This integer value is used to construct a string in the format TEXCOORD_<set index> which is a reference to a key in mesh.primitives.attributes (e.g. A value of 0 corresponds to TEXCOORD_0)."
    # MaterialNormalTextureInfo
    def TexCoord(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Dictionary object with extension-specific objects.
    # MaterialNormalTextureInfo
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # MaterialNormalTextureInfo
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # MaterialNormalTextureInfo
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MaterialNormalTextureInfo
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # Application-specific data.
    # MaterialNormalTextureInfo
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # MaterialNormalTextureInfo
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # MaterialNormalTextureInfo
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MaterialNormalTextureInfo
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def MaterialNormalTextureInfoStart(builder):
    builder.StartObject(5)

def MaterialNormalTextureInfoAddScale(builder, scale):
    builder.PrependFloat32Slot(0, scale, 1.0)

def MaterialNormalTextureInfoAddIndex(builder, index):
    builder.PrependInt32Slot(1, index, -1)

def MaterialNormalTextureInfoAddTexCoord(builder, texCoord):
    builder.PrependInt32Slot(2, texCoord, 0)

def MaterialNormalTextureInfoAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def MaterialNormalTextureInfoStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def MaterialNormalTextureInfoAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def MaterialNormalTextureInfoStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def MaterialNormalTextureInfoEnd(builder):
    return builder.EndObject()



# Material Occlusion Texture Info
class MaterialOcclusionTextureInfo(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = MaterialOcclusionTextureInfo()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMaterialOcclusionTextureInfo(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # MaterialOcclusionTextureInfo
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "A scalar multiplier controlling the amount of occlusion applied."
    # "gltf_detailedDescription": "A scalar multiplier controlling the amount of occlusion applied. A value of 0.0 means no occlusion. A value of 1.0 means full occlusion. This value affects the resulting color using the formula: `occludedColor = lerp(color, color * <sampled occlusion texture value>, <occlusion strength>)`. This value is ignored if the corresponding texture is not specified. This value is linear.
    # MaterialOcclusionTextureInfo
    def Strength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 1.0

    # "description": "The index of the texture."
    # MaterialOcclusionTextureInfo
    def Index(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

    # "description": "The set index of texture's TEXCOORD attribute used for texture coordinate mapping."
    # "gltf_detailedDescription": "This integer value is used to construct a string in the format TEXCOORD_<set index> which is a reference to a key in mesh.primitives.attributes (e.g. A value of 0 corresponds to TEXCOORD_0)."
    # MaterialOcclusionTextureInfo
    def TexCoord(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Dictionary object with extension-specific objects.
    # MaterialOcclusionTextureInfo
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # MaterialOcclusionTextureInfo
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # MaterialOcclusionTextureInfo
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MaterialOcclusionTextureInfo
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # Application-specific data.
    # MaterialOcclusionTextureInfo
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # MaterialOcclusionTextureInfo
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # MaterialOcclusionTextureInfo
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MaterialOcclusionTextureInfo
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def MaterialOcclusionTextureInfoStart(builder):
    builder.StartObject(5)

def MaterialOcclusionTextureInfoAddStrength(builder, strength):
    builder.PrependFloat32Slot(0, strength, 1.0)

def MaterialOcclusionTextureInfoAddIndex(builder, index):
    builder.PrependInt32Slot(1, index, -1)

def MaterialOcclusionTextureInfoAddTexCoord(builder, texCoord):
    builder.PrependInt32Slot(2, texCoord, 0)

def MaterialOcclusionTextureInfoAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def MaterialOcclusionTextureInfoStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def MaterialOcclusionTextureInfoAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def MaterialOcclusionTextureInfoStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def MaterialOcclusionTextureInfoEnd(builder):
    return builder.EndObject()



# Material PBR Metallic Roughness
# "description": "A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology."
class MaterialPbrMetallicRoughness(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = MaterialPbrMetallicRoughness()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMaterialPbrMetallicRoughness(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # MaterialPbrMetallicRoughness
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "The material's base color factor."
    # "gltf_detailedDescription": "The RGBA components of the base color of the material. The fourth component (A) is the alpha coverage of the material. The `alphaMode` property specifies how alpha is interpreted. These values are linear. If a baseColorTexture is specified, this value is multiplied with the texel values."
    # "minItems": 4
    # "maxItems": 4
    # "default": [ 1.0, 1.0, 1.0, 1.0 ]
    # MaterialPbrMetallicRoughness
    def BaseColorFactor(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # MaterialPbrMetallicRoughness
    def BaseColorFactorAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # MaterialPbrMetallicRoughness
    def BaseColorFactorLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MaterialPbrMetallicRoughness
    def BaseColorFactorIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # "description": "The base color texture."
    # "gltf_detailedDescription": "The base color texture. This texture contains RGB(A) components in sRGB color space. The first three components (RGB) specify the base color of the material. If the fourth component (A) is present, it represents the alpha coverage of the material. Otherwise, an alpha of 1.0 is assumed. The `alphaMode` property specifies how alpha is interpreted. The stored texels must not be premultiplied."
    # MaterialPbrMetallicRoughness
    def BaseColorTexture(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = TextureInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # "description": "The metalness of the material."
    # "gltf_detailedDescription": "The metalness of the material. A value of 1.0 means the material is a metal. A value of 0.0 means the material is a dielectric. Values in between are for blending between metals and dielectrics such as dirty metallic surfaces. This value is linear. If a metallicRoughnessTexture is specified, this value is multiplied with the metallic texel values."
    # MaterialPbrMetallicRoughness
    def MetallicFactor(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 1.0

    # "description": "The roughness of the material."
    # "gltf_detailedDescription": "The roughness of the material. A value of 1.0 means the material is completely rough. A value of 0.0 means the material is completely smooth. This value is linear. If a metallicRoughnessTexture is specified, this value is multiplied with the roughness texel values."
    # "minimum": 0.0
    # "maximum": 1.0
    # "default": 1.0
    # MaterialPbrMetallicRoughness
    def RoughnessFactor(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 1.0

    # "description": "The metallic-roughness texture."
    # "gltf_detailedDescription": "The metallic-roughness texture. The metalness values are sampled from the B channel. The roughness values are sampled from the G channel. These values are linear. If other channels are present (R or A), they are ignored for metallic-roughness calculations."
    # MaterialPbrMetallicRoughness
    def MetallicRoughnessTexture(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = TextureInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Dictionary object with extension-specific objects.
    # MaterialPbrMetallicRoughness
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # MaterialPbrMetallicRoughness
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # MaterialPbrMetallicRoughness
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MaterialPbrMetallicRoughness
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # Application-specific data.
    # MaterialPbrMetallicRoughness
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # MaterialPbrMetallicRoughness
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # MaterialPbrMetallicRoughness
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MaterialPbrMetallicRoughness
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

def MaterialPbrMetallicRoughnessStart(builder):
    builder.StartObject(7)

def MaterialPbrMetallicRoughnessAddBaseColorFactor(builder, baseColorFactor):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(baseColorFactor), 0)

def MaterialPbrMetallicRoughnessStartBaseColorFactorVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def MaterialPbrMetallicRoughnessAddBaseColorTexture(builder, baseColorTexture):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(baseColorTexture), 0)

def MaterialPbrMetallicRoughnessAddMetallicFactor(builder, metallicFactor):
    builder.PrependFloat32Slot(2, metallicFactor, 1.0)

def MaterialPbrMetallicRoughnessAddRoughnessFactor(builder, roughnessFactor):
    builder.PrependFloat32Slot(3, roughnessFactor, 1.0)

def MaterialPbrMetallicRoughnessAddMetallicRoughnessTexture(builder, metallicRoughnessTexture):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(metallicRoughnessTexture), 0)

def MaterialPbrMetallicRoughnessAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def MaterialPbrMetallicRoughnessStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def MaterialPbrMetallicRoughnessAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def MaterialPbrMetallicRoughnessStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def MaterialPbrMetallicRoughnessEnd(builder):
    return builder.EndObject()



# Material
# "description": "The material appearance of a primitive."
class Material(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Material()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMaterial(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Material
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology. When not specified, all the default values of `pbrMetallicRoughness` apply."
    # Material
    def PbrMetallicRoughness(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = MaterialPbrMetallicRoughness()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # "description": "The normal map texture."
    # "gltf_detailedDescription": "A tangent space normal map. The texture contains RGB components in linear space. Each texel represents the XYZ components of a normal vector in tangent space. Red [0 to 255] maps to X [-1 to 1]. Green [0 to 255] maps to Y [-1 to 1]. Blue [128 to 255] maps to Z [1/255 to 1]. The normal vectors use OpenGL conventions where +X is right and +Y is up. +Z points toward the viewer. In GLSL, this vector would be unpacked like so: `float3 normalVector = tex2D(<sampled normal map texture value>, texCoord) * 2 - 1`."
    # Material
    def NormalTexture(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = MaterialNormalTextureInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # "description": "The occlusion map texture."
    # "gltf_detailedDescription": "The occlusion map texture. The occlusion values are sampled from the R channel. Higher values indicate areas that should receive full indirect lighting and lower values indicate no indirect lighting. These values are linear. If other channels are present (GBA), they are ignored for occlusion calculations."
    # Material
    def OcclusionTexture(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = MaterialOcclusionTextureInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # "description": "The emissive map texture."
    # "gltf_detailedDescription": "The emissive map controls the color and intensity of the light being emitted by the material. This texture contains RGB components in sRGB color space. If a fourth component (A) is present, it is ignored."
    # Material
    def EmissiveTexture(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = TextureInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # "description": "The emissive color of the material."
    # "gltf_detailedDescription": "The RGB components of the emissive color of the material. These values are linear. If an emissiveTexture is specified, this value is multiplied with the texel values."
    # "minItems": 3,
    # "maxItems": 3,
    # "default": [ 0.0, 0.0, 0.0 ],
    # Material
    def EmissiveFactor(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Material
    def EmissiveFactorAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # Material
    def EmissiveFactorLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Material
    def EmissiveFactorIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # Dictionary object with extension-specific objects.
    # Material
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Material
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Material
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Material
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # Application-specific data.
    # Material
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Material
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Material
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Material
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # "description": "Specifies whether the material is double sided."
    # "gltf_detailedDescription": "Specifies whether the material is double sided. When this value is false, back-face culling is enabled. When this value is true, back-face culling is disabled and double sided lighting is enabled. The back-face must have its normals reversed before the lighting equation is evaluated."
    # Material
    def DoubleSided(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # The user-defined name of this object.
    # gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an accessor and a buffer could have the same name, or two accessors could even have the same name.
    # Material
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # "description": "The alpha cutoff value of the material."
    # "gltf_detailedDescription": "Specifies the cutoff threshold when in `MASK` mode. If the alpha value is greater than or equal to this value then it is rendered as fully opaque, otherwise, it is rendered as fully transparent. A value greater than 1.0 will render the entire material as fully transparent. This value is ignored for other modes."
    # Material
    def AlphaCutoff(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.5

    # "description": "The alpha rendering mode of the material."
    # "gltf_detailedDescription": "The material's alpha rendering mode enumeration specifying the interpretation of the alpha value of the main factor and texture."
    # Material
    def AlphaMode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)
        return 0

def MaterialStart(builder):
    builder.StartObject(11)

def MaterialAddPbrMetallicRoughness(builder, pbrMetallicRoughness):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(pbrMetallicRoughness), 0)

def MaterialAddNormalTexture(builder, normalTexture):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(normalTexture), 0)

def MaterialAddOcclusionTexture(builder, occlusionTexture):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(occlusionTexture), 0)

def MaterialAddEmissiveTexture(builder, emissiveTexture):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(emissiveTexture), 0)

def MaterialAddEmissiveFactor(builder, emissiveFactor):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(emissiveFactor), 0)

def MaterialStartEmissiveFactorVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def MaterialAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def MaterialStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def MaterialAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def MaterialStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def MaterialAddDoubleSided(builder, doubleSided):
    builder.PrependBoolSlot(7, doubleSided, 0)

def MaterialAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def MaterialAddAlphaCutoff(builder, alphaCutoff):
    builder.PrependFloat32Slot(9, alphaCutoff, 0.5)

def MaterialAddAlphaMode(builder, alphaMode):
    builder.PrependInt16Slot(10, alphaMode, 0)

def MaterialEnd(builder):
    return builder.EndObject()



class MeshPrimitiveAttribute(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = MeshPrimitiveAttribute()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMeshPrimitiveAttribute(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # MeshPrimitiveAttribute
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # MeshPrimitiveAttribute
    def Id(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # MeshPrimitiveAttribute
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

def MeshPrimitiveAttributeStart(builder):
    builder.StartObject(2)

def MeshPrimitiveAttributeAddId(builder, id):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(id), 0)

def MeshPrimitiveAttributeAddValue(builder, value):
    builder.PrependInt32Slot(1, value, -1)

def MeshPrimitiveAttributeEnd(builder):
    return builder.EndObject()



# Mesh Primitive
# "description": "Geometry to be rendered with the given material."
# "gltf_webgl": "`drawElements()` and `drawArrays()`"
class MeshPrimitive(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = MeshPrimitive()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMeshPrimitive(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # MeshPrimitive
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "A dictionary object, where each key corresponds to mesh attribute semantic and each value is the index of the accessor containing attribute's data."
    #! NOTE: dictionary objects are not possible with flatbuffers (yet), hence this workaround
    # MeshPrimitive
    def Attributes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # MeshPrimitive
    def AttributesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # MeshPrimitive
    def AttributesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MeshPrimitive
    def AttributesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Dictionary object with extension-specific objects.
    # MeshPrimitive
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # MeshPrimitive
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # MeshPrimitive
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MeshPrimitive
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # "description": "An array of Morph Targets, each  Morph Target is a dictionary mapping attributes (only `POSITION`, `NORMAL`, and `TANGENT` supported) to their deviations in the Morph Target."
    # "description": "A dictionary object specifying attributes displacements in a Morph Target, where each key corresponds to one of the three supported attribute semantic (`POSITION`, `NORMAL`, or `TANGENT`) and each value is the index of the accessor containing the attribute displacements' data."
    # MeshPrimitive
    def Targets(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # MeshPrimitive
    def TargetsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # MeshPrimitive
    def TargetsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MeshPrimitive
    def TargetsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # "description": "The index of the accessor that contains the indices."
    # "gltf_detailedDescription": "The index of the accessor that contains mesh indices.  When this is not defined, the primitives should be rendered without indices using `drawArrays()`.  When defined, the accessor must contain indices: the `bufferView` referenced by the accessor should have a `target` equal to 34963 (ELEMENT_ARRAY_BUFFER); `componentType` must be 5121 (UNSIGNED_BYTE), 5123 (UNSIGNED_SHORT) or 5125 (UNSIGNED_INT), the latter may require enabling additional hardware support; `type` must be `\"SCALAR\"`. For triangle primitives, the front face has a counter-clockwise (CCW) winding order."
    # MeshPrimitive
    def Indices(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

    # "description": "The index of the material to apply to this primitive when rendering."
    # MeshPrimitive
    def Material(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

    # "description": "The type of primitives to render."
    # "gltf_detailedDescription": "The type of primitives to render. All valid values correspond to WebGL enums."
    # MeshPrimitive
    def Mode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 4

    # Application-specific data.
    # MeshPrimitive
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # MeshPrimitive
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # MeshPrimitive
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MeshPrimitive
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

def MeshPrimitiveStart(builder):
    builder.StartObject(7)

def MeshPrimitiveAddAttributes(builder, attributes):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(attributes), 0)

def MeshPrimitiveStartAttributesVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def MeshPrimitiveAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def MeshPrimitiveStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def MeshPrimitiveAddTargets(builder, targets):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(targets), 0)

def MeshPrimitiveStartTargetsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def MeshPrimitiveAddIndices(builder, indices):
    builder.PrependInt32Slot(3, indices, -1)

def MeshPrimitiveAddMaterial(builder, material):
    builder.PrependInt32Slot(4, material, -1)

def MeshPrimitiveAddMode(builder, mode):
    builder.PrependUint8Slot(5, mode, 4)

def MeshPrimitiveAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def MeshPrimitiveStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def MeshPrimitiveEnd(builder):
    return builder.EndObject()



# Mesh
# "description": "A set of primitives to be rendered.  A node can contain one mesh.  A node's transform places the mesh in the scene."
class Mesh(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Mesh()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMesh(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Mesh
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Dictionary object with extension-specific objects.
    # Mesh
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Mesh
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Mesh
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Mesh
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Application-specific data.
    # Mesh
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Mesh
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Mesh
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Mesh
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # The user-defined name of this object.
    # gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an accessor and a buffer could have the same name, or two accessors could even have the same name.
    # Mesh
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # "description": "An array of primitives, each defining geometry to be rendered with a material."
    # Mesh
    def Primitives(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = MeshPrimitive()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Mesh
    def PrimitivesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Mesh
    def PrimitivesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # "description": "Array of weights to be applied to the Morph Targets."
    # Mesh
    def Weights(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Mesh
    def WeightsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # Mesh
    def WeightsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Mesh
    def WeightsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def MeshStart(builder):
    builder.StartObject(5)

def MeshAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def MeshStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def MeshAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def MeshStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def MeshAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def MeshAddPrimitives(builder, primitives):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(primitives), 0)

def MeshStartPrimitivesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def MeshAddWeights(builder, weights):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(weights), 0)

def MeshStartWeightsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def MeshEnd(builder):
    return builder.EndObject()



#----------------------------------------------------------------------------
# Node
# "description": "A node in the node hierarchy.  When the node contains `skin`, all `mesh.primitives` must contain `JOINTS_0` and `WEIGHTS_0` attributes.  A node can have either a `matrix` or any combination of `translation`/`rotation`/`scale` (TRS) properties. TRS properties are converted to matrices and postmultiplied in the `T * R * S` order to compose the transformation matrix; first the scale is applied to the vertices, then the rotation, and then the translation. If none are provided, the transform is the identity. When a node is targeted for animation (referenced by an animation.channel.target), only TRS properties may be present; `matrix` will not be present."
class Node(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Node()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsNode(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Node
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "The index of the camera referenced by this node."
    # Node
    def Camera(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

    # "description": "The indices of this node's children."
    # Node
    def Children(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Node
    def ChildrenAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Node
    def ChildrenLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Node
    def ChildrenIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Dictionary object with extension-specific objects.
    # Node
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Node
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Node
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Node
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Application-specific data.
    # Node
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Node
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Node
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Node
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # "description": "The weights of the instantiated Morph Target. Number of elements must match number of Morph Targets of used mesh."
    # "minItems": 1
    # Node
    def Weights(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Node
    def WeightsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # Node
    def WeightsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Node
    def WeightsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # "description": "The index of the mesh in this node."
    # Node
    def Mesh(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

    # The user-defined name of this object.
    # gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an accessor and a buffer could have the same name, or two accessors could even have the same name.
    # Node
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # "description": "The node's unit quaternion rotation in the order (x, y, z, w), where w is the scalar."
    # "minimum": -1.0
    # "maximum": 1.0
    # "minItems": 4
    # "maxItems": 4
    # "default": [ 0.0, 0.0, 0.0, 1.0 ]
    # Node
    def Rotation(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Node
    def RotationAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # Node
    def RotationLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Node
    def RotationIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # "description": "The node's non-uniform scale."
    # "minItems": 3
    # "maxItems": 3
    # "default": [ 1.0, 1.0, 1.0 ]
    # Node
    def Scale(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Node
    def ScaleAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # Node
    def ScaleLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Node
    def ScaleIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return o == 0

    # "description": "The index of the skin referenced by this node."
    # Node
    def Skin(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

    # "description": "The node's translation."
    # "minItems": 3
    # "maxItems": 3
    # "default": [ 0.0, 0.0, 0.0 ]
    # Node
    def Translation(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Node
    def TranslationAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # Node
    def TranslationLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Node
    def TranslationIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        return o == 0

    # "description": "A floating-point 4x4 transformation matrix stored in column-major order."
    # "gltf_detailedDescription": "A floating-point 4x4 transformation matrix stored in column-major order."
    # "gltf_webgl": "`uniformMatrix4fv()` with the transpose parameter equal to false"
    # "minItems": 16
    # "maxItems": 16
    # "default": [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ],
    # Node
    def Matrix(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Node
    def MatrixAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # Node
    def MatrixLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Node
    def MatrixIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        return o == 0

def NodeStart(builder):
    builder.StartObject(12)

def NodeAddCamera(builder, camera):
    builder.PrependInt32Slot(0, camera, -1)

def NodeAddChildren(builder, children):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(children), 0)

def NodeStartChildrenVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def NodeAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def NodeStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def NodeAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def NodeStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def NodeAddWeights(builder, weights):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(weights), 0)

def NodeStartWeightsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def NodeAddMesh(builder, mesh):
    builder.PrependInt32Slot(5, mesh, -1)

def NodeAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def NodeAddRotation(builder, rotation):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(rotation), 0)

def NodeStartRotationVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def NodeAddScale(builder, scale):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(scale), 0)

def NodeStartScaleVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def NodeAddSkin(builder, skin):
    builder.PrependInt32Slot(9, skin, -1)

def NodeAddTranslation(builder, translation):
    builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(translation), 0)

def NodeStartTranslationVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def NodeAddMatrix(builder, matrix):
    builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(matrix), 0)

def NodeStartMatrixVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def NodeEnd(builder):
    return builder.EndObject()



#----------------------------------------------------------------------------
# Scene
# "description": "The root nodes of a scene."
class Scene(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Scene()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsScene(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Scene
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Dictionary object with extension-specific objects.
    # Scene
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Scene
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Scene
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Scene
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Application-specific data.
    # Scene
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Scene
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Scene
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Scene
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # The user-defined name of this object.
    # gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an accessor and a buffer could have the same name, or two accessors could even have the same name.
    # Scene
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # "description": "The indices of each root node."
    # Scene
    def Nodes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Scene
    def NodesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Scene
    def NodesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Scene
    def NodesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

def SceneStart(builder):
    builder.StartObject(4)

def SceneAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def SceneStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def SceneAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def SceneStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def SceneAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def SceneAddNodes(builder, nodes):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(nodes), 0)

def SceneStartNodesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def SceneEnd(builder):
    return builder.EndObject()



# Sampler
# "description": "Texture sampler properties for filtering and wrapping modes."
# "gltf_webgl": "`texParameterf()`"
class Sampler(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Sampler()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSampler(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Sampler
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # "description": "s wrapping mode."
    # "gltf_detailedDescription": "s wrapping mode.  All valid values correspond to WebGL enums."
    # "gltf_webgl": "`texParameterf()` with pname equal to TEXTURE_WRAP_S"
    # Sampler
    def WrapS(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 10497

    # "description": "t wrapping mode."
    # "gltf_detailedDescription": "t wrapping mode.  All valid values correspond to WebGL enums."
    # "gltf_webgl": "`texParameterf()` with pname equal to TEXTURE_WRAP_T"
    # Sampler
    def WrapT(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 10497

    # "description": "Magnification filter."
    # "gltf_detailedDescription": "Magnification filter.  Valid values correspond to WebGL enums: `9728` (NEAREST) and `9729` (LINEAR)."
    # "gltf_webgl": "`texParameterf()` with pname equal to TEXTURE_MAG_FILTER"
    # Sampler
    def MagFilter(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint16Flags, o + self._tab.Pos)
        return 9728

    # "description": "Minification filter."
    # "gltf_detailedDescription": "Minification filter.  All valid values correspond to WebGL enums."
    # "gltf_webgl": "`texParameterf()` with pname equal to TEXTURE_MIN_FILTER"
    # Sampler
    def MinFilter(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint16Flags, o + self._tab.Pos)
        return 9728

    # The user-defined name of this object.
    # gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an accessor and a buffer could have the same name, or two accessors could even have the same name.
    # Sampler
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Dictionary object with extension-specific objects.
    # Sampler
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Sampler
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Sampler
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Sampler
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # Application-specific data.
    # Sampler
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Sampler
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Sampler
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Sampler
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

def SamplerStart(builder):
    builder.StartObject(7)

def SamplerAddWrapS(builder, wrapS):
    builder.PrependInt32Slot(0, wrapS, 10497)

def SamplerAddWrapT(builder, wrapT):
    builder.PrependInt32Slot(1, wrapT, 10497)

def SamplerAddMagFilter(builder, magFilter):
    builder.PrependUint16Slot(2, magFilter, 9728)

def SamplerAddMinFilter(builder, minFilter):
    builder.PrependUint16Slot(3, minFilter, 9728)

def SamplerAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def SamplerAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def SamplerStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def SamplerAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def SamplerStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def SamplerEnd(builder):
    return builder.EndObject()



#----------------------------------------------------------------------------
# Texture
# "description": "A texture and its sampler."
# "gltf_webgl": "`createTexture()`, `deleteTexture()`, `bindTexture()`, `texImage2D()`, and `texParameterf()`"
class Texture(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Texture()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTexture(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Texture
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # The user-defined name of this object.
    # gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an accessor and a buffer could have the same name, or two accessors could even have the same name.
    # Texture
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Dictionary object with extension-specific objects.
    # Texture
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Texture
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Texture
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Texture
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Application-specific data.
    # Texture
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Texture
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Texture
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Texture
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # "description": "The index of the sampler used by this texture. When undefined, a sampler with repeat wrapping and auto filtering should be used."
    # Texture
    def Sampler(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

    # "description": "The index of the image used by this texture."
    # Texture
    def Source(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

def TextureStart(builder):
    builder.StartObject(5)

def TextureAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def TextureAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def TextureStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def TextureAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def TextureStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def TextureAddSampler(builder, sampler):
    builder.PrependInt32Slot(3, sampler, -1)

def TextureAddSource(builder, source):
    builder.PrependInt32Slot(4, source, -1)

def TextureEnd(builder):
    return builder.EndObject()



#----------------------------------------------------------------------------
# Skin
# "description": "Joints and matrices defining a skin."
class Skin(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Skin()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSkin(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Skin
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Dictionary object with extension-specific objects.
    # Skin
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Skin
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Skin
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Skin
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Application-specific data.
    # Skin
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Skin
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Skin
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Skin
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # "description": "The index of the accessor containing the floating-point 4x4 inverse-bind matrices.  The default is that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were pre-applied."
    # Skin
    def InverseBindMatrices(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

    # "description": "Indices of skeleton nodes, used as joints in this skin."
    # "gltf_detailedDescription": "Indices of skeleton nodes, used as joints in this skin.  The array length must be the same as the `count` property of the `inverseBindMatrices` accessor (when defined)."
    # Skin
    def Joints(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Skin
    def JointsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Skin
    def JointsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Skin
    def JointsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # The user-defined name of this object.
    # gltf_detailedDescription: The user-defined name of this object.  This is not necessarily unique, e.g., an accessor and a buffer could have the same name, or two accessors could even have the same name.
    # Skin
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # "description": "The index of the node used as a skeleton root. When undefined, joints transforms resolve to scene root."
    # Skin
    def Skeleton(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

def SkinStart(builder):
    builder.StartObject(6)

def SkinAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def SkinStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def SkinAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def SkinStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def SkinAddInverseBindMatrices(builder, inverseBindMatrices):
    builder.PrependInt32Slot(2, inverseBindMatrices, -1)

def SkinAddJoints(builder, joints):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(joints), 0)

def SkinStartJointsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def SkinAddName(builder, name):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def SkinAddSkeleton(builder, skeleton):
    builder.PrependInt32Slot(5, skeleton, -1)

def SkinEnd(builder):
    return builder.EndObject()



#----------------------------------------------------------------------------
# The root object for a glTF asset.
class Root(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Root()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsRoot(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Root
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # An array of accessors.
    # gltf_detailedDescription: An array of accessors.  An accessor is a typed view into a bufferView.
    # Root
    def Accessors(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Accessor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Root
    def AccessorsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def AccessorsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # An array of keyframe animations.
    # Root
    def Animations(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Animation()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Root
    def AnimationsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def AnimationsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Metadata about the glTF asset.
    # Root
    def Asset(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Asset()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # An array of bufferViews.
    # gltf_detailedDescription: An array of bufferViews.  A bufferView is a view into a buffer generally representing a subset of the buffer.
    # Root
    def BufferViews(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = BufferView()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Root
    def BufferViewsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def BufferViewsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # An array of buffers.
    # gltf_detailedDescription: An array of buffers.  A buffer points to binary geometry, animation, or skins.
    # Root
    def Buffers(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Buffer()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Root
    def BuffersLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def BuffersIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # An array of cameras.
    # gltf_detailedDescription: An array of cameras.  A camera defines a projection matrix.
    # Root
    def Cameras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Camera()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Root
    def CamerasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def CamerasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    #-- glTFProperty
    # Dictionary object with extension-specific objects.
    # Root
    def Extensions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Root
    def ExtensionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Root
    def ExtensionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def ExtensionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # Names of glTF extensions required to properly load this asset.
    # Root
    def ExtensionsRequired(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Root
    def ExtensionsRequiredLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def ExtensionsRequiredIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # Names of glTF extensions used somewhere in this asset.
    # Root
    def ExtensionsUsed(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Root
    def ExtensionsUsedLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def ExtensionsUsedIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return o == 0

    # Application-specific data.
    # Root
    def Extras(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Root
    def ExtrasAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Root
    def ExtrasLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def ExtrasIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        return o == 0

    # An array of images.
    # gltf_detailedDescription: An array of images.  An image defines data used to create a texture.
    # Root
    def Images(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Image()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Root
    def ImagesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def ImagesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        return o == 0

    # An array of materials.
    # gltf_detailedDescription: An array of materials.  A material defines the appearance of a primitive.
    # Root
    def Materials(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Material()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Root
    def MaterialsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def MaterialsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        return o == 0

    # An array of meshes.
    # gltf_detailedDescription: An array of meshes.  A mesh is a set of primitives to be rendered.
    # Root
    def Meshes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Mesh()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Root
    def MeshesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def MeshesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        return o == 0

    # An array of nodes.
    # Root
    def Nodes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Node()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Root
    def NodesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def NodesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        return o == 0

    # An array of samplers.
    # gltf_detailedDescription: An array of samplers.  A sampler contains properties for texture filtering and wrapping modes.
    # Root
    def Samplers(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Sampler()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Root
    def SamplersLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def SamplersIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        return o == 0

    # The index of the default scene.
    # Root
    def Scene(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return -1

    # An array of scenes.
    # Root
    def Scenes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Scene()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Root
    def ScenesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def ScenesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        return o == 0

    # An array of skins.
    # gltf_detailedDescription: An array of skins.  A skin is defined by joints and matrices.
    # Root
    def Skins(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Skin()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Root
    def SkinsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def SkinsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        return o == 0

    # An array of textures.
    # Root
    def Textures(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(40))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Texture()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Root
    def TexturesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(40))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Root
    def TexturesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(40))
        return o == 0

def RootStart(builder):
    builder.StartObject(19)

def RootAddAccessors(builder, accessors):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(accessors), 0)

def RootStartAccessorsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def RootAddAnimations(builder, animations):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(animations), 0)

def RootStartAnimationsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def RootAddAsset(builder, asset):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(asset), 0)

def RootAddBufferViews(builder, bufferViews):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(bufferViews), 0)

def RootStartBufferViewsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def RootAddBuffers(builder, buffers):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(buffers), 0)

def RootStartBuffersVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def RootAddCameras(builder, cameras):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(cameras), 0)

def RootStartCamerasVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def RootAddExtensions(builder, extensions):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(extensions), 0)

def RootStartExtensionsVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def RootAddExtensionsRequired(builder, extensionsRequired):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(extensionsRequired), 0)

def RootStartExtensionsRequiredVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def RootAddExtensionsUsed(builder, extensionsUsed):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(extensionsUsed), 0)

def RootStartExtensionsUsedVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def RootAddExtras(builder, extras):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(extras), 0)

def RootStartExtrasVector(builder, numElems):
    return builder.StartVector(1, numElems, 1)

def RootAddImages(builder, images):
    builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(images), 0)

def RootStartImagesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def RootAddMaterials(builder, materials):
    builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(materials), 0)

def RootStartMaterialsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def RootAddMeshes(builder, meshes):
    builder.PrependUOffsetTRelativeSlot(12, flatbuffers.number_types.UOffsetTFlags.py_type(meshes), 0)

def RootStartMeshesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def RootAddNodes(builder, nodes):
    builder.PrependUOffsetTRelativeSlot(13, flatbuffers.number_types.UOffsetTFlags.py_type(nodes), 0)

def RootStartNodesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def RootAddSamplers(builder, samplers):
    builder.PrependUOffsetTRelativeSlot(14, flatbuffers.number_types.UOffsetTFlags.py_type(samplers), 0)

def RootStartSamplersVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def RootAddScene(builder, scene):
    builder.PrependInt32Slot(15, scene, -1)

def RootAddScenes(builder, scenes):
    builder.PrependUOffsetTRelativeSlot(16, flatbuffers.number_types.UOffsetTFlags.py_type(scenes), 0)

def RootStartScenesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def RootAddSkins(builder, skins):
    builder.PrependUOffsetTRelativeSlot(17, flatbuffers.number_types.UOffsetTFlags.py_type(skins), 0)

def RootStartSkinsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def RootAddTextures(builder, textures):
    builder.PrependUOffsetTRelativeSlot(18, flatbuffers.number_types.UOffsetTFlags.py_type(textures), 0)

def RootStartTexturesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def RootEnd(builder):
    return builder.EndObject()



